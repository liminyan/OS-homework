### 启动顺序

1. 段寄存器的字段含义和功能有哪些？
```
Base（段基址）: 段的起始地址
Limit（段界）: 段的大小
Attribute（段属性）: 段的权限等各种属性
Selector（段选择子）: 用于索引段表，进行逻辑-线性地址转换
```
2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？
```
DPL：对应段的特权等级。存在于Attribute位。
CPL：当前执行的代码段的特权等级。存在于CS寄存器中。
RPL：进程对段访问的特权级。存在于Selector。
```
3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
```
   硬件压栈内容：EFLAGS, CS, EIP, ErrorCode, 可能还有SS, ESP.
   内核态中断无堆栈切换。用户态中断需要切换到内核态栈，且额外压入SS, ESP.
```
2. 为什么在用户态的中断响应要使用内核堆栈？
```因为中断服务例程需要在内核态运行
```
3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
``` interrupt类型 在调用的时候会禁止中断调用
    trap类型 在调用的时候不会
    若不区分 都禁止，则系统调用的时候不会触发其他的硬件中断，或都不禁止可能会引起重复触发或者嵌套过多的问题
```


### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
ebp是当前函数的栈基地址，函数调用时会发生变化，所以设计成内联的，不是函数调用，ebp就不会变。
eip是下一条指令的地址，因此使用非内联函数可以直接从栈中读取到eip。
### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
不是，IDT即中断描述表还没有建立
